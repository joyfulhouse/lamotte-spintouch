# SpinTouch Reader - ESPHome Configuration
# LaMotte SpinTouch Water Quality Sensor Integration
#
# This is an ALTERNATIVE to using the custom Home Assistant integration
# with ESPHome Bluetooth Proxies. Use this approach when you want:
# - A dedicated ESP32 device for SpinTouch
# - Local processing without Home Assistant dependency
# - The device to work standalone with its own web UI
#
# For most users, the custom integration with existing Bluetooth proxies
# is recommended. See the custom_components/spintouch directory.

substitutions:
  # Device settings
  device_name: spintouch
  friendly_name: SpinTouch Reader

  # SpinTouch BLE MAC address
  # To find your device's MAC: power on SpinTouch, check logs or
  # "Detected SpinTouch MAC" sensor - it auto-detects by service UUID
  spintouch_mac: "BB:BD:05:0B:2D:1F"

  # Ideal ranges for pool water (customize as needed)
  # Free Chlorine
  fc_min: "1.0"
  fc_max: "3.0"
  # pH
  ph_min: "7.2"
  ph_max: "7.6"
  # Total Alkalinity
  alk_min: "80"
  alk_max: "120"
  # Calcium Hardness
  ca_min: "200"
  ca_max: "400"
  # Cyanuric Acid
  cya_min: "30"
  cya_max: "50"
  # Salt (for saltwater pools, 0 for non-salt)
  salt_min: "2700"
  salt_max: "3400"
  # Iron
  iron_max: "0.3"
  # Copper
  copper_max: "0.3"
  # Phosphate (ppb)
  phosphate_max: "100"
  # Borate
  borate_min: "30"
  borate_max: "50"
  # Bromine (for bromine pools)
  bromine_min: "2.0"
  bromine_max: "4.0"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: lolin_c3_mini
  variant: ESP32C3
  framework:
    type: esp-idf

# Required for BLE on ESP32-C3 with esp-idf
esp32_ble:
  io_capability: display_only
  max_connections: 4

bluetooth_proxy:
  active: true

# Enable logging
logger:
  level: DEBUG
  logs:
    esp32_ble_tracker: INFO

# Web server for viewing logs and configuration
web_server:
  port: 80

# Enable Home Assistant API
api:
  encryption:
    key: "VoUIKaHLLXLy3roUCaGniTV1VIoarur7cDJFE+0ev6Y="

ota:
  - platform: esphome
    password: "eb225ab78ac30f5bc9470be969070ed0"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "SpinTouch Fallback Hotspot"
    password: "mKiFYXwq4Gws"

# Time sync for timestamps
time:
  - platform: homeassistant
    id: ha_time

# Global variables for state tracking and persistence
globals:
  - id: reading_received
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: last_reading_timestamp
    type: uint32_t
    restore_value: yes
    initial_value: '0'

  # Persistent sensor values (survive reboot)
  - id: g_free_chlorine
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_total_chlorine
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_ph
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_alkalinity
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_calcium
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_cya
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_salt
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_iron
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_phosphate
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_bromine
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_copper
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_borate
    type: float
    restore_value: yes
    initial_value: 'NAN'

# BLE tracking with SpinTouch auto-discovery
esp32_ble_tracker:
  scan_parameters:
    active: true
    interval: 100ms
    window: 100ms
    continuous: true
  on_ble_service_advertise:
    # Auto-detect SpinTouch devices by service UUID
    - service_uuid: "00000000-0000-1000-8000-bbbd00000000"
      then:
        - lambda: |-
            ESP_LOGW("spintouch", ">>> SPINTOUCH DETECTED: %s (RSSI: %d) <<<",
                     x.address_str().c_str(), x.get_rssi());
        - text_sensor.template.publish:
            id: detected_spintouch_mac
            state: !lambda 'return x.address_str();'

# BLE Client - connects to SpinTouch
ble_client:
  - mac_address: ${spintouch_mac}
    id: spintouch
    auto_connect: true
    on_connect:
      then:
        - text_sensor.template.publish:
            id: last_connection_time
            state: !lambda 'return id(ha_time).now().strftime("%Y-%m-%d %H:%M:%S");'
        - logger.log:
            level: WARN
            format: "=== CONNECTED TO SPINTOUCH - Ready to receive ==="
    on_disconnect:
      then:
        - logger.log:
            level: WARN
            format: "=== DISCONNECTED FROM SPINTOUCH ==="

# Scripts for managing connection lifecycle
script:
  - id: handle_reading_received
    mode: restart
    then:
      - lambda: |-
          id(reading_received) = true;
          id(last_reading_timestamp) = id(ha_time).now().timestamp;
      - text_sensor.template.publish:
          id: last_reading_time
          state: !lambda 'return id(ha_time).now().strftime("%Y-%m-%d %H:%M:%S");'
      - logger.log:
          level: INFO
          format: "Reading received, starting disconnect timer..."
      # Wait for disconnect delay (no new data timeout)
      - delay: !lambda 'return id(disconnect_delay).state * 1000;'
      - if:
          condition:
            lambda: 'return id(reading_received);'
          then:
            - logger.log:
                level: WARN
                format: "No new data after timeout, disconnecting to allow phone app access..."
            - lambda: |-
                id(spintouch).set_enabled(false);
            # Wait for reconnect delay before allowing reconnection
            - delay: !lambda 'return id(reconnect_delay).state * 1000;'
            - logger.log:
                level: WARN
                format: "Reconnect delay expired, re-enabling connection..."
            - lambda: |-
                id(reading_received) = false;
                id(spintouch).set_enabled(true);

# Configurable settings (accessible via Web UI)
number:
  - platform: template
    name: "Disconnect Delay"
    id: disconnect_delay
    min_value: 5
    max_value: 120
    step: 1
    initial_value: 10
    unit_of_measurement: "s"
    optimistic: true
    restore_value: true
    icon: "mdi:timer-off"
    entity_category: config

  - platform: template
    name: "Reconnect Delay"
    id: reconnect_delay
    min_value: 60
    max_value: 1800
    step: 60
    initial_value: 300
    unit_of_measurement: "s"
    optimistic: true
    restore_value: true
    icon: "mdi:timer"
    entity_category: config

# Diagnostic text sensors
text_sensor:
  - platform: template
    name: "Last Reading Time"
    id: last_reading_time
    icon: "mdi:clock-outline"

  - platform: template
    name: "Last Connection Time"
    id: last_connection_time
    icon: "mdi:bluetooth-connect"
    entity_category: diagnostic

  - platform: template
    name: "Detected SpinTouch MAC"
    id: detected_spintouch_mac
    icon: "mdi:bluetooth-search"
    entity_category: diagnostic

# Sensors from SpinTouch
sensor:
  # Status notifications - triggers read when SpinTouch sends data
  - platform: ble_client
    type: characteristic
    ble_client_id: spintouch
    name: "SpinTouch Status"
    id: spintouch_status
    internal: true
    service_uuid: "00000000-0000-1000-8000-bbbd00000000"
    characteristic_uuid: "00000000-0000-1000-8000-bbbd00000011"
    notify: true
    lambda: |-
      if (x.size() > 0) {
        ESP_LOGW("spintouch", "Status notification received, reading results...");
        id(spintouch_raw).update();
      }
      return 0;

  # Main BLE sensor - reads test results when triggered
  - platform: ble_client
    type: characteristic
    ble_client_id: spintouch
    name: "SpinTouch Raw"
    id: spintouch_raw
    internal: true
    service_uuid: "00000000-0000-1000-8000-bbbd00000000"
    characteristic_uuid: "00000000-0000-1000-8000-bbbd00000010"
    update_interval: never
    lambda: |-
      // Minimum data size: 4-byte header + at least one 6-byte entry
      if (x.size() < 10) {
        ESP_LOGW("spintouch", "Data too short: %d bytes", x.size());
        return NAN;
      }

      // Verify start signature [0x01, 0x02, 0x03, 0x05]
      if (x[0] != 0x01 || x[1] != 0x02 || x[2] != 0x03 || x[3] != 0x05) {
        ESP_LOGW("spintouch", "Invalid start signature");
        return NAN;
      }

      ESP_LOGI("spintouch", "Received %d bytes with valid signature", x.size());

      // Helper to validate float values
      auto is_valid = [](float v) -> bool {
        return !isnan(v) && !isinf(v) && v >= -10000 && v <= 100000;
      };

      // Param ID constants (from TestType enum in decompiled app)
      const uint8_t PARAM_FREE_CHLORINE = 0x01;
      const uint8_t PARAM_TOTAL_CHLORINE = 0x02;
      const uint8_t PARAM_BROMINE = 0x03;
      const uint8_t PARAM_PH = 0x06;
      const uint8_t PARAM_ALKALINITY = 0x07;
      const uint8_t PARAM_CALCIUM_HR = 0x08;
      const uint8_t PARAM_CYANURIC_ACID = 0x0A;
      const uint8_t PARAM_IRON = 0x0B;
      const uint8_t PARAM_COPPER = 0x0C;
      const uint8_t PARAM_BORATE = 0x0D;
      const uint8_t PARAM_PHOSPHATE = 0x0E;
      const uint8_t PARAM_CALCIUM = 0x0F;
      const uint8_t PARAM_SALT = 0x10;
      const uint8_t PARAM_COMBINED_CHLORINE = 0x11;

      // Parse entries by scanning for param IDs
      // Format: 4-byte header, then 6-byte entries [param_id, decimals, float32_le]
      // Maximum 12 entries, ends at timestamp offset (76) or end signature
      const int HEADER_SIZE = 4;
      const int ENTRY_SIZE = 6;
      const int MAX_ENTRIES = 12;

      for (int i = 0; i < MAX_ENTRIES; i++) {
        int offset = HEADER_SIZE + (i * ENTRY_SIZE);
        if (offset + ENTRY_SIZE > x.size()) break;

        uint8_t param_id = x[offset];
        // uint8_t decimals = x[offset + 1];  // Available if needed
        float value = *reinterpret_cast<const float*>(&x[offset + 2]);

        // Check for end signature (entry starts with 0x07)
        if (param_id == 0x07 && x[offset + 1] == 0x0B) {
          ESP_LOGD("spintouch", "End signature found at entry %d", i);
          break;
        }

        // Skip invalid/empty entries
        if (param_id == 0x00 || !is_valid(value)) continue;

        ESP_LOGD("spintouch", "Entry %d: param=0x%02X value=%.2f", i, param_id, value);

        // Map param_id to sensor
        switch (param_id) {
          case PARAM_FREE_CHLORINE:
            if (value >= 0 && value <= 20) {
              id(g_free_chlorine) = value;
              id(free_chlorine).publish_state(value);
            }
            break;
          case PARAM_TOTAL_CHLORINE:
            if (value >= 0 && value <= 20) {
              id(g_total_chlorine) = value;
              id(total_chlorine).publish_state(value);
            }
            break;
          case PARAM_BROMINE:
            if (value >= 0 && value <= 20) {
              id(g_bromine) = value;
              id(bromine_sensor).publish_state(value);
            }
            break;
          case PARAM_PH:
            if (value >= 0 && value <= 14) {
              id(g_ph) = value;
              id(ph_sensor).publish_state(value);
            }
            break;
          case PARAM_ALKALINITY:
            if (value >= 0 && value <= 500) {
              id(g_alkalinity) = value;
              id(alkalinity).publish_state(value);
            }
            break;
          case PARAM_CALCIUM:
          case PARAM_CALCIUM_HR:
            if (value >= 0 && value <= 1200) {
              id(g_calcium) = value;
              id(calcium).publish_state(value);
            }
            break;
          case PARAM_CYANURIC_ACID:
            if (value >= 0 && value <= 300) {
              id(g_cya) = value;
              id(cya_sensor).publish_state(value);
            }
            break;
          case PARAM_SALT:
            if (value >= 0 && value <= 10000) {
              id(g_salt) = value;
              id(salt_sensor).publish_state(value);
            }
            break;
          case PARAM_COPPER:
            if (value >= 0 && value <= 5) {
              id(g_copper) = value;
              id(copper_sensor).publish_state(value);
            }
            break;
          case PARAM_IRON:
            if (value >= 0 && value <= 5) {
              id(g_iron) = value;
              id(iron_sensor).publish_state(value);
            }
            break;
          case PARAM_PHOSPHATE:
            if (value >= 0 && value <= 2500) {
              id(g_phosphate) = value;
              id(phosphate).publish_state(value);
            }
            break;
          case PARAM_BORATE:
            if (value >= 0 && value <= 100) {
              id(g_borate) = value;
              id(borate_sensor).publish_state(value);
            }
            break;
          case PARAM_COMBINED_CHLORINE:
            // Device-reported combined chlorine (may not always be present)
            ESP_LOGD("spintouch", "Device-reported CC: %.2f", value);
            break;
          default:
            ESP_LOGD("spintouch", "Unknown param 0x%02X: %.2f", param_id, value);
            break;
        }
      }

      ESP_LOGI("spintouch", "FC:%.2f TC:%.2f BR:%.2f pH:%.2f Alk:%.0f Ca:%.0f CYA:%.0f Salt:%.0f Cu:%.3f Fe:%.3f PO4:%.0f BOR:%.1f",
               id(g_free_chlorine), id(g_total_chlorine), id(g_bromine), id(g_ph), id(g_alkalinity),
               id(g_calcium), id(g_cya), id(g_salt), id(g_copper), id(g_iron), id(g_phosphate), id(g_borate));

      // Trigger the disconnect timer script
      id(handle_reading_received).execute();

      return id(g_free_chlorine);

  # ===== Primary Water Quality Sensors =====

  - platform: template
    name: "Free Chlorine"
    id: free_chlorine
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask"
    lambda: 'return id(g_free_chlorine);'
    update_interval: 60s

  - platform: template
    name: "Total Chlorine"
    id: total_chlorine
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask"
    lambda: 'return id(g_total_chlorine);'
    update_interval: 60s

  - platform: template
    name: "pH"
    id: ph_sensor
    accuracy_decimals: 2
    icon: "mdi:ph"
    lambda: 'return id(g_ph);'
    update_interval: 60s

  - platform: template
    name: "Total Alkalinity"
    id: alkalinity
    unit_of_measurement: "ppm"
    accuracy_decimals: 1
    icon: "mdi:water"
    lambda: 'return id(g_alkalinity);'
    update_interval: 60s

  - platform: template
    name: "Calcium Hardness"
    id: calcium
    unit_of_measurement: "ppm"
    accuracy_decimals: 1
    icon: "mdi:water"
    lambda: 'return id(g_calcium);'
    update_interval: 60s

  - platform: template
    name: "Cyanuric Acid"
    id: cya_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 1
    icon: "mdi:shield-sun"
    lambda: 'return id(g_cya);'
    update_interval: 60s

  - platform: template
    name: "Salt"
    id: salt_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 0
    icon: "mdi:shaker"
    lambda: 'return id(g_salt);'
    update_interval: 60s

  - platform: template
    name: "Iron"
    id: iron_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 3
    icon: "mdi:iron"
    lambda: 'return id(g_iron);'
    update_interval: 60s

  - platform: template
    name: "Phosphate"
    id: phosphate
    unit_of_measurement: "ppb"
    accuracy_decimals: 1
    icon: "mdi:leaf"
    lambda: 'return id(g_phosphate);'
    update_interval: 60s

  - platform: template
    name: "Bromine"
    id: bromine_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask"
    lambda: 'return id(g_bromine);'
    update_interval: 60s

  - platform: template
    name: "Copper"
    id: copper_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask"
    lambda: 'return id(g_copper);'
    update_interval: 60s

  - platform: template
    name: "Borate"
    id: borate_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 1
    icon: "mdi:flask-outline"
    lambda: 'return id(g_borate);'
    update_interval: 60s

  # ===== Calculated Sensors =====

  - platform: template
    name: "Combined Chlorine"
    id: combined_chlorine
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask-outline"
    lambda: |-
      float fc = id(g_free_chlorine);
      float tc = id(g_total_chlorine);
      if (isnan(fc) || isnan(tc)) return NAN;
      float cc = tc - fc;
      return (cc >= 0) ? cc : 0;
    update_interval: 60s

  - platform: template
    name: "FC/CYA Ratio"
    id: fc_cya_ratio
    unit_of_measurement: "%"
    accuracy_decimals: 1
    icon: "mdi:percent"
    lambda: |-
      float fc = id(g_free_chlorine);
      float cya = id(g_cya);
      if (isnan(fc) || isnan(cya) || cya <= 0) return NAN;
      return (fc / cya) * 100.0;
    update_interval: 60s

  - platform: template
    name: "Test Age"
    id: test_age
    unit_of_measurement: "min"
    accuracy_decimals: 0
    icon: "mdi:clock-alert-outline"
    lambda: |-
      uint32_t last = id(last_reading_timestamp);
      if (last == 0) return NAN;
      uint32_t now = id(ha_time).now().timestamp;
      if (now < last) return NAN;
      return (now - last) / 60.0;
    update_interval: 60s

  # ===== Diagnostic Sensors =====

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    entity_category: diagnostic

  - platform: uptime
    name: "Uptime"
    update_interval: 60s
    entity_category: diagnostic

# ===== Binary Sensors - Connection Status & Range Indicators =====
binary_sensor:
  - platform: template
    name: "SpinTouch Connected"
    id: spintouch_connected
    lambda: return id(spintouch).connected();
    device_class: connectivity

  - platform: template
    name: "Connection Enabled"
    lambda: return id(spintouch).enabled;
    entity_category: diagnostic
    icon: "mdi:bluetooth-settings"

  # Range indicators
  - platform: template
    name: "Free Chlorine In Range"
    id: fc_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_free_chlorine);
      if (isnan(v)) return false;
      return v >= ${fc_min} && v <= ${fc_max};

  - platform: template
    name: "pH In Range"
    id: ph_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_ph);
      if (isnan(v)) return false;
      return v >= ${ph_min} && v <= ${ph_max};

  - platform: template
    name: "Alkalinity In Range"
    id: alk_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_alkalinity);
      if (isnan(v)) return false;
      return v >= ${alk_min} && v <= ${alk_max};

  - platform: template
    name: "Calcium In Range"
    id: ca_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_calcium);
      if (isnan(v)) return false;
      return v >= ${ca_min} && v <= ${ca_max};

  - platform: template
    name: "Cyanuric Acid In Range"
    id: cya_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_cya);
      if (isnan(v)) return false;
      return v >= ${cya_min} && v <= ${cya_max};

  - platform: template
    name: "Salt In Range"
    id: salt_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_salt);
      if (isnan(v)) return false;
      // If salt_min is 0, treat as non-saltwater pool (always in range if 0)
      if (${salt_min} == 0 && v == 0) return true;
      return v >= ${salt_min} && v <= ${salt_max};

  - platform: template
    name: "Iron In Range"
    id: iron_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_iron);
      if (isnan(v)) return false;
      return v <= ${iron_max};

  - platform: template
    name: "Phosphate In Range"
    id: phosphate_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_phosphate);
      if (isnan(v)) return false;
      return v <= ${phosphate_max};

  - platform: template
    name: "Bromine In Range"
    id: bromine_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_bromine);
      if (isnan(v)) return false;
      return v >= ${bromine_min} && v <= ${bromine_max};

  - platform: template
    name: "Copper In Range"
    id: copper_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_copper);
      if (isnan(v)) return false;
      return v <= ${copper_max};

  - platform: template
    name: "Borate In Range"
    id: borate_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_borate);
      if (isnan(v)) return false;
      return v >= ${borate_min} && v <= ${borate_max};

  - platform: template
    name: "All Parameters In Range"
    id: all_in_range
    icon: "mdi:check-decagram"
    device_class: problem
    lambda: |-
      // Returns true if ANY parameter is out of range (problem detected)
      // Only check sensors that have valid (non-NaN) values
      bool has_problem = false;

      // Check chlorine sensors (skip if NaN - not tested)
      if (!isnan(id(g_free_chlorine)) && !id(fc_in_range).state) has_problem = true;
      if (!isnan(id(g_ph)) && !id(ph_in_range).state) has_problem = true;
      if (!isnan(id(g_alkalinity)) && !id(alk_in_range).state) has_problem = true;
      if (!isnan(id(g_calcium)) && !id(ca_in_range).state) has_problem = true;
      if (!isnan(id(g_cya)) && !id(cya_in_range).state) has_problem = true;
      if (!isnan(id(g_iron)) && !id(iron_in_range).state) has_problem = true;
      if (!isnan(id(g_phosphate)) && !id(phosphate_in_range).state) has_problem = true;
      if (!isnan(id(g_bromine)) && !id(bromine_in_range).state) has_problem = true;
      if (!isnan(id(g_copper)) && !id(copper_in_range).state) has_problem = true;
      if (!isnan(id(g_borate)) && !id(borate_in_range).state) has_problem = true;

      return has_problem;

# ===== Buttons =====
button:
  - platform: restart
    name: "Restart"
    entity_category: config

  - platform: template
    name: "Force Reconnect"
    icon: "mdi:bluetooth-connect"
    entity_category: config
    on_press:
      then:
        - logger.log:
            level: WARN
            format: "Force reconnect requested..."
        - lambda: |-
            id(reading_received) = false;
            id(spintouch).set_enabled(true);

