# SpinTouch Reader - ESPHome Configuration
# LaMotte SpinTouch Water Quality Sensor Integration

substitutions:
  # Device settings
  device_name: spintouch
  friendly_name: SpinTouch Reader

  # SpinTouch BLE MAC address
  # To find your device's MAC: power on SpinTouch, check logs or
  # "Detected SpinTouch MAC" sensor - it auto-detects by service UUID
  spintouch_mac: "BB:BD:05:0B:2D:1F"

  # Ideal ranges for pool water (customize as needed)
  # Free Chlorine
  fc_min: "1.0"
  fc_max: "3.0"
  # pH
  ph_min: "7.2"
  ph_max: "7.6"
  # Total Alkalinity
  alk_min: "80"
  alk_max: "120"
  # Calcium Hardness
  ca_min: "200"
  ca_max: "400"
  # Cyanuric Acid
  cya_min: "30"
  cya_max: "50"
  # Salt (for saltwater pools, 0 for non-salt)
  salt_min: "2700"
  salt_max: "3400"
  # Iron
  iron_max: "0.3"
  # Phosphate (ppb)
  phosphate_max: "100"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: lolin_c3_mini
  variant: ESP32C3
  framework:
    type: esp-idf

# Required for BLE on ESP32-C3 with esp-idf
esp32_ble:
  io_capability: display_only
  max_connections: 4

bluetooth_proxy:
  active: true

# Enable logging
logger:
  level: DEBUG
  logs:
    esp32_ble_tracker: INFO

# Web server for viewing logs and configuration
web_server:
  port: 80

# Enable Home Assistant API
api:
  encryption:
    key: "VoUIKaHLLXLy3roUCaGniTV1VIoarur7cDJFE+0ev6Y="

ota:
  - platform: esphome
    password: "eb225ab78ac30f5bc9470be969070ed0"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "SpinTouch Fallback Hotspot"
    password: "mKiFYXwq4Gws"

# Time sync for timestamps
time:
  - platform: homeassistant
    id: ha_time

# Global variables for state tracking and persistence
globals:
  - id: reading_received
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: last_reading_timestamp
    type: uint32_t
    restore_value: yes
    initial_value: '0'

  # Persistent sensor values (survive reboot)
  - id: g_free_chlorine
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_total_chlorine
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_ph
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_alkalinity
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_calcium
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_cya
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_salt
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_iron
    type: float
    restore_value: yes
    initial_value: 'NAN'

  - id: g_phosphate
    type: float
    restore_value: yes
    initial_value: 'NAN'

# BLE tracking with SpinTouch auto-discovery
esp32_ble_tracker:
  scan_parameters:
    active: true
    interval: 100ms
    window: 100ms
    continuous: true
  on_ble_service_advertise:
    # Auto-detect SpinTouch devices by service UUID
    - service_uuid: "00000000-0000-1000-8000-bbbd00000000"
      then:
        - lambda: |-
            ESP_LOGW("spintouch", ">>> SPINTOUCH DETECTED: %s (RSSI: %d) <<<",
                     x.address_str().c_str(), x.get_rssi());
        - text_sensor.template.publish:
            id: detected_spintouch_mac
            state: !lambda 'return x.address_str();'

# BLE Client - connects to SpinTouch
ble_client:
  - mac_address: ${spintouch_mac}
    id: spintouch
    auto_connect: true
    on_connect:
      then:
        - text_sensor.template.publish:
            id: last_connection_time
            state: !lambda 'return id(ha_time).now().strftime("%Y-%m-%d %H:%M:%S");'
        - logger.log:
            level: WARN
            format: "=== CONNECTED TO SPINTOUCH - Ready to receive ==="
    on_disconnect:
      then:
        - logger.log:
            level: WARN
            format: "=== DISCONNECTED FROM SPINTOUCH ==="

# Scripts for managing connection lifecycle
script:
  - id: handle_reading_received
    mode: restart
    then:
      - lambda: |-
          id(reading_received) = true;
          id(last_reading_timestamp) = id(ha_time).now().timestamp;
      - text_sensor.template.publish:
          id: last_reading_time
          state: !lambda 'return id(ha_time).now().strftime("%Y-%m-%d %H:%M:%S");'
      - logger.log:
          level: INFO
          format: "Reading received, starting disconnect timer..."
      # Wait for disconnect delay (no new data timeout)
      - delay: !lambda 'return id(disconnect_delay).state * 1000;'
      - if:
          condition:
            lambda: 'return id(reading_received);'
          then:
            - logger.log:
                level: WARN
                format: "No new data after timeout, disconnecting to allow phone app access..."
            - lambda: |-
                id(spintouch).set_enabled(false);
            # Wait for reconnect delay before allowing reconnection
            - delay: !lambda 'return id(reconnect_delay).state * 1000;'
            - logger.log:
                level: WARN
                format: "Reconnect delay expired, re-enabling connection..."
            - lambda: |-
                id(reading_received) = false;
                id(spintouch).set_enabled(true);

# Configurable settings (accessible via Web UI)
number:
  - platform: template
    name: "Disconnect Delay"
    id: disconnect_delay
    min_value: 5
    max_value: 120
    step: 1
    initial_value: 10
    unit_of_measurement: "s"
    optimistic: true
    restore_value: true
    icon: "mdi:timer-off"
    entity_category: config

  - platform: template
    name: "Reconnect Delay"
    id: reconnect_delay
    min_value: 60
    max_value: 1800
    step: 60
    initial_value: 300
    unit_of_measurement: "s"
    optimistic: true
    restore_value: true
    icon: "mdi:timer"
    entity_category: config

# Diagnostic text sensors
text_sensor:
  - platform: template
    name: "Last Reading Time"
    id: last_reading_time
    icon: "mdi:clock-outline"

  - platform: template
    name: "Last Connection Time"
    id: last_connection_time
    icon: "mdi:bluetooth-connect"
    entity_category: diagnostic

  - platform: template
    name: "Detected SpinTouch MAC"
    id: detected_spintouch_mac
    icon: "mdi:bluetooth-search"
    entity_category: diagnostic

# Sensors from SpinTouch
sensor:
  # Status notifications - triggers read when SpinTouch sends data
  - platform: ble_client
    type: characteristic
    ble_client_id: spintouch
    name: "SpinTouch Status"
    id: spintouch_status
    internal: true
    service_uuid: "00000000-0000-1000-8000-bbbd00000000"
    characteristic_uuid: "00000000-0000-1000-8000-bbbd00000011"
    notify: true
    lambda: |-
      if (x.size() > 0) {
        ESP_LOGW("spintouch", "Status notification received, reading results...");
        id(spintouch_raw).update();
      }
      return 0;

  # Main BLE sensor - reads test results when triggered
  - platform: ble_client
    type: characteristic
    ble_client_id: spintouch
    name: "SpinTouch Raw"
    id: spintouch_raw
    internal: true
    service_uuid: "00000000-0000-1000-8000-bbbd00000000"
    characteristic_uuid: "00000000-0000-1000-8000-bbbd00000010"
    update_interval: never
    lambda: |-
      if (x.size() < 70) {
        ESP_LOGW("spintouch", "Data too short: %d bytes", x.size());
        return NAN;
      }
      ESP_LOGI("spintouch", "Received %d bytes", x.size());

      // Helper lambda to validate float values
      auto is_valid = [](float v) -> bool {
        return !isnan(v) && !isinf(v) && v >= -10000 && v <= 100000;
      };

      // Parse all parameters from BLE data
      // Format: 4-byte header, then 6-byte entries [param_id, flags, float32_le]

      // Offset 4: Free Chlorine (0x01)
      float fc = *reinterpret_cast<const float*>(&x[6]);
      if (is_valid(fc) && fc >= 0 && fc <= 20) {
        id(g_free_chlorine) = fc;
        id(free_chlorine).publish_state(fc);
      } else {
        ESP_LOGW("spintouch", "Invalid FC value: %.2f", fc);
      }

      // Offset 10: Total Chlorine (0x02)
      float tc = *reinterpret_cast<const float*>(&x[12]);
      if (is_valid(tc) && tc >= 0 && tc <= 20) {
        id(g_total_chlorine) = tc;
        id(total_chlorine).publish_state(tc);
      } else {
        ESP_LOGW("spintouch", "Invalid TC value: %.2f", tc);
      }

      // Offset 22: pH (0x06)
      float ph = *reinterpret_cast<const float*>(&x[24]);
      if (is_valid(ph) && ph >= 0 && ph <= 14) {
        id(g_ph) = ph;
        id(ph_sensor).publish_state(ph);
      } else {
        ESP_LOGW("spintouch", "Invalid pH value: %.2f", ph);
      }

      // Offset 28: Alkalinity (0x07)
      float alk = *reinterpret_cast<const float*>(&x[30]);
      if (is_valid(alk) && alk >= 0 && alk <= 500) {
        id(g_alkalinity) = alk;
        id(alkalinity).publish_state(alk);
      } else {
        ESP_LOGW("spintouch", "Invalid Alkalinity value: %.2f", alk);
      }

      // Offset 34: Calcium Hardness (0x0F)
      float ca = *reinterpret_cast<const float*>(&x[36]);
      if (is_valid(ca) && ca >= 0 && ca <= 1000) {
        id(g_calcium) = ca;
        id(calcium).publish_state(ca);
      } else {
        ESP_LOGW("spintouch", "Invalid Calcium value: %.2f", ca);
      }

      // Offset 40: Cyanuric Acid (0x0A)
      float cya = *reinterpret_cast<const float*>(&x[42]);
      if (is_valid(cya) && cya >= 0 && cya <= 300) {
        id(g_cya) = cya;
        id(cya_sensor).publish_state(cya);
      } else {
        ESP_LOGW("spintouch", "Invalid CYA value: %.2f", cya);
      }

      // Offset 46: Salt (0x0C)
      float salt = *reinterpret_cast<const float*>(&x[48]);
      if (is_valid(salt) && salt >= 0 && salt <= 10000) {
        id(g_salt) = salt;
        id(salt_sensor).publish_state(salt);
      } else {
        ESP_LOGW("spintouch", "Invalid Salt value: %.2f", salt);
      }

      // Offset 52: Iron (0x0B)
      float iron = *reinterpret_cast<const float*>(&x[54]);
      if (is_valid(iron) && iron >= 0 && iron <= 10) {
        id(g_iron) = iron;
        id(iron_sensor).publish_state(iron);
      } else {
        ESP_LOGW("spintouch", "Invalid Iron value: %.2f", iron);
      }

      // Offset 58: Phosphate (0x0D)
      float phos = *reinterpret_cast<const float*>(&x[60]);
      if (is_valid(phos) && phos >= 0 && phos <= 2000) {
        id(g_phosphate) = phos;
        id(phosphate).publish_state(phos);
      } else {
        ESP_LOGW("spintouch", "Invalid Phosphate value: %.2f", phos);
      }

      ESP_LOGI("spintouch", "FC:%.2f TC:%.2f pH:%.2f Alk:%.0f Ca:%.0f CYA:%.0f Salt:%.0f Fe:%.3f PO4:%.0f",
               id(g_free_chlorine), id(g_total_chlorine), id(g_ph), id(g_alkalinity),
               id(g_calcium), id(g_cya), id(g_salt), id(g_iron), id(g_phosphate));

      // Trigger the disconnect timer script
      id(handle_reading_received).execute();

      return id(g_free_chlorine);

  # ===== Primary Water Quality Sensors =====

  - platform: template
    name: "Free Chlorine"
    id: free_chlorine
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask"
    lambda: 'return id(g_free_chlorine);'
    update_interval: 60s

  - platform: template
    name: "Total Chlorine"
    id: total_chlorine
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask"
    lambda: 'return id(g_total_chlorine);'
    update_interval: 60s

  - platform: template
    name: "pH"
    id: ph_sensor
    accuracy_decimals: 2
    icon: "mdi:ph"
    lambda: 'return id(g_ph);'
    update_interval: 60s

  - platform: template
    name: "Total Alkalinity"
    id: alkalinity
    unit_of_measurement: "ppm"
    accuracy_decimals: 1
    icon: "mdi:water"
    lambda: 'return id(g_alkalinity);'
    update_interval: 60s

  - platform: template
    name: "Calcium Hardness"
    id: calcium
    unit_of_measurement: "ppm"
    accuracy_decimals: 1
    icon: "mdi:water"
    lambda: 'return id(g_calcium);'
    update_interval: 60s

  - platform: template
    name: "Cyanuric Acid"
    id: cya_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 1
    icon: "mdi:shield-sun"
    lambda: 'return id(g_cya);'
    update_interval: 60s

  - platform: template
    name: "Salt"
    id: salt_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 0
    icon: "mdi:shaker"
    lambda: 'return id(g_salt);'
    update_interval: 60s

  - platform: template
    name: "Iron"
    id: iron_sensor
    unit_of_measurement: "ppm"
    accuracy_decimals: 3
    icon: "mdi:iron"
    lambda: 'return id(g_iron);'
    update_interval: 60s

  - platform: template
    name: "Phosphate"
    id: phosphate
    unit_of_measurement: "ppb"
    accuracy_decimals: 1
    icon: "mdi:leaf"
    lambda: 'return id(g_phosphate);'
    update_interval: 60s

  # ===== Calculated Sensors =====

  - platform: template
    name: "Combined Chlorine"
    id: combined_chlorine
    unit_of_measurement: "ppm"
    accuracy_decimals: 2
    icon: "mdi:flask-outline"
    lambda: |-
      float fc = id(g_free_chlorine);
      float tc = id(g_total_chlorine);
      if (isnan(fc) || isnan(tc)) return NAN;
      float cc = tc - fc;
      return (cc >= 0) ? cc : 0;
    update_interval: 60s

  - platform: template
    name: "FC/CYA Ratio"
    id: fc_cya_ratio
    unit_of_measurement: "%"
    accuracy_decimals: 1
    icon: "mdi:percent"
    lambda: |-
      float fc = id(g_free_chlorine);
      float cya = id(g_cya);
      if (isnan(fc) || isnan(cya) || cya <= 0) return NAN;
      return (fc / cya) * 100.0;
    update_interval: 60s

  - platform: template
    name: "Test Age"
    id: test_age
    unit_of_measurement: "min"
    accuracy_decimals: 0
    icon: "mdi:clock-alert-outline"
    lambda: |-
      uint32_t last = id(last_reading_timestamp);
      if (last == 0) return NAN;
      uint32_t now = id(ha_time).now().timestamp;
      if (now < last) return NAN;
      return (now - last) / 60.0;
    update_interval: 60s

  # ===== Diagnostic Sensors =====

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    entity_category: diagnostic

  - platform: uptime
    name: "Uptime"
    update_interval: 60s
    entity_category: diagnostic

# ===== Binary Sensors - Connection Status & Range Indicators =====
binary_sensor:
  - platform: template
    name: "SpinTouch Connected"
    id: spintouch_connected
    lambda: return id(spintouch).connected();
    device_class: connectivity

  - platform: template
    name: "Connection Enabled"
    lambda: return id(spintouch).enabled;
    entity_category: diagnostic
    icon: "mdi:bluetooth-settings"

  # Range indicators
  - platform: template
    name: "Free Chlorine In Range"
    id: fc_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_free_chlorine);
      if (isnan(v)) return false;
      return v >= ${fc_min} && v <= ${fc_max};

  - platform: template
    name: "pH In Range"
    id: ph_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_ph);
      if (isnan(v)) return false;
      return v >= ${ph_min} && v <= ${ph_max};

  - platform: template
    name: "Alkalinity In Range"
    id: alk_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_alkalinity);
      if (isnan(v)) return false;
      return v >= ${alk_min} && v <= ${alk_max};

  - platform: template
    name: "Calcium In Range"
    id: ca_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_calcium);
      if (isnan(v)) return false;
      return v >= ${ca_min} && v <= ${ca_max};

  - platform: template
    name: "Cyanuric Acid In Range"
    id: cya_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_cya);
      if (isnan(v)) return false;
      return v >= ${cya_min} && v <= ${cya_max};

  - platform: template
    name: "Salt In Range"
    id: salt_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_salt);
      if (isnan(v)) return false;
      // If salt_min is 0, treat as non-saltwater pool (always in range if 0)
      if (${salt_min} == 0 && v == 0) return true;
      return v >= ${salt_min} && v <= ${salt_max};

  - platform: template
    name: "Iron In Range"
    id: iron_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_iron);
      if (isnan(v)) return false;
      return v <= ${iron_max};

  - platform: template
    name: "Phosphate In Range"
    id: phosphate_in_range
    icon: "mdi:check-circle"
    lambda: |-
      float v = id(g_phosphate);
      if (isnan(v)) return false;
      return v <= ${phosphate_max};

  - platform: template
    name: "All Parameters In Range"
    id: all_in_range
    icon: "mdi:check-decagram"
    device_class: problem
    lambda: |-
      // Returns true if ANY parameter is out of range (problem detected)
      bool fc_ok = id(fc_in_range).state;
      bool ph_ok = id(ph_in_range).state;
      bool alk_ok = id(alk_in_range).state;
      bool ca_ok = id(ca_in_range).state;
      bool cya_ok = id(cya_in_range).state;
      bool iron_ok = id(iron_in_range).state;
      bool phos_ok = id(phosphate_in_range).state;
      // Return true if there's a problem (inverted for device_class: problem)
      return !(fc_ok && ph_ok && alk_ok && ca_ok && cya_ok && iron_ok && phos_ok);

# ===== Buttons =====
button:
  - platform: restart
    name: "Restart"
    entity_category: config

  - platform: template
    name: "Force Reconnect"
    icon: "mdi:bluetooth-connect"
    entity_category: config
    on_press:
      then:
        - logger.log:
            level: WARN
            format: "Force reconnect requested..."
        - lambda: |-
            id(reading_received) = false;
            id(spintouch).set_enabled(true);

